/* tslint:disable */
/* eslint-disable */
/**
 * Anon Frontend Services
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.3.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AnonymizedDocument
 */
export interface AnonymizedDocument {
    /**
     * 
     * @type {string}
     * @memberof AnonymizedDocument
     */
    'caseFileNumber': string;
    /**
     * 
     * @type {DocumentTypeEnum}
     * @memberof AnonymizedDocument
     */
    'documentType'?: DocumentTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AnonymizedDocument
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AnonymizedDocument
     */
    'originalAuthor': string;
    /**
     * 
     * @type {string}
     * @memberof AnonymizedDocument
     */
    'lastChangeAuthor'?: string;
    /**
     * Timestamp of the created date
     * @type {string}
     * @memberof AnonymizedDocument
     */
    'createdDate': string;
    /**
     * Timestamp of the most recent annotations change
     * @type {string}
     * @memberof AnonymizedDocument
     */
    'lastChangeDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof AnonymizedDocument
     */
    'courtId': number;
    /**
     * 
     * @type {AnonymizedSectionsSections}
     * @memberof AnonymizedDocument
     */
    'sections'?: AnonymizedSectionsSections;
}


/**
 * 
 * @export
 * @interface AnonymizedSections
 */
export interface AnonymizedSections {
    /**
     * 
     * @type {AnonymizedSectionsSections}
     * @memberof AnonymizedSections
     */
    'sections'?: AnonymizedSectionsSections;
}
/**
 * 
 * @export
 * @interface AnonymizedSectionsSections
 */
export interface AnonymizedSectionsSections {
    /**
     * 
     * @type {string}
     * @memberof AnonymizedSectionsSections
     */
    'hlavicka'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnonymizedSectionsSections
     */
    'rozhodnutie'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnonymizedSectionsSections
     */
    'odovodnenie'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnonymizedSectionsSections
     */
    'poucenie'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnonymizedSectionsSections
     */
    'votum'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnonymizedSectionsSections
     */
    'pravnaVeta'?: string;
}
/**
 * 
 * @export
 * @interface ApplicationInfo
 */
export interface ApplicationInfo {
    /**
     * 
     * @type {ApplicationInfoApp}
     * @memberof ApplicationInfo
     */
    'app'?: ApplicationInfoApp;
    /**
     * 
     * @type {ApplicationInfoModels}
     * @memberof ApplicationInfo
     */
    'models'?: ApplicationInfoModels;
}
/**
 * 
 * @export
 * @interface ApplicationInfoApp
 */
export interface ApplicationInfoApp {
    /**
     * application version
     * @type {string}
     * @memberof ApplicationInfoApp
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface ApplicationInfoModels
 */
export interface ApplicationInfoModels {
    /**
     * 
     * @type {ModelInfo}
     * @memberof ApplicationInfoModels
     */
    'anon'?: ModelInfo;
    /**
     * 
     * @type {ModelInfo}
     * @memberof ApplicationInfoModels
     */
    'ner'?: ModelInfo;
}
/**
 * 
 * @export
 * @interface AuditLog
 */
export interface AuditLog {
    /**
     * Page size
     * @type {number}
     * @memberof AuditLog
     */
    'size': number;
    /**
     * total count of elements
     * @type {number}
     * @memberof AuditLog
     */
    'totalElements': number;
    /**
     * total count of pages
     * @type {number}
     * @memberof AuditLog
     */
    'totalPages': number;
    /**
     * current page number
     * @type {number}
     * @memberof AuditLog
     */
    'number': number;
    /**
     * 
     * @type {Array<AuditRecord>}
     * @memberof AuditLog
     */
    'records': Array<AuditRecord>;
}
/**
 * 
 * @export
 * @interface AuditRecord
 */
export interface AuditRecord {
    /**
     * Timestamp of the audit event
     * @type {string}
     * @memberof AuditRecord
     */
    'dateTime': string;
    /**
     * 
     * @type {string}
     * @memberof AuditRecord
     */
    'auditor': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AuditRecord
     */
    'events': Array<AuditRecordEventsEnum>;
}

export const AuditRecordEventsEnum = {
    AddEntities: 'ADD_ENTITIES',
    EditEntities: 'EDIT_ENTITIES',
    RemoveEntities: 'REMOVE_ENTITIES',
    Anonymize: 'ANONYMIZE',
    DeleteDocument: 'DELETE_DOCUMENT'
} as const;

export type AuditRecordEventsEnum = typeof AuditRecordEventsEnum[keyof typeof AuditRecordEventsEnum];

/**
 * 
 * @export
 * @interface BadRequest
 */
export interface BadRequest {
    /**
     * 
     * @type {Array<BadRequestErrorsInner>}
     * @memberof BadRequest
     */
    'errors': Array<BadRequestErrorsInner>;
}
/**
 * 
 * @export
 * @interface BadRequestErrorsInner
 */
export interface BadRequestErrorsInner {
    /**
     * 
     * @type {string}
     * @memberof BadRequestErrorsInner
     */
    'fieldName'?: string;
    /**
     * 
     * @type {string}
     * @memberof BadRequestErrorsInner
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface BasicDocument
 */
export interface BasicDocument {
    /**
     * 
     * @type {string}
     * @memberof BasicDocument
     */
    'caseFileNumber': string;
    /**
     * 
     * @type {DocumentTypeEnum}
     * @memberof BasicDocument
     */
    'documentType'?: DocumentTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof BasicDocument
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BasicDocument
     */
    'originalAuthor': string;
    /**
     * 
     * @type {string}
     * @memberof BasicDocument
     */
    'lastChangeAuthor'?: string;
    /**
     * Timestamp of the created date
     * @type {string}
     * @memberof BasicDocument
     */
    'createdDate': string;
    /**
     * Timestamp of the most recent annotations change
     * @type {string}
     * @memberof BasicDocument
     */
    'lastChangeDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof BasicDocument
     */
    'courtId': number;
}


/**
 * 
 * @export
 * @interface CaseFileNumber
 */
export interface CaseFileNumber {
    /**
     * 
     * @type {string}
     * @memberof CaseFileNumber
     */
    'caseFileNumber': string;
}
/**
 * 
 * @export
 * @interface Court
 */
export interface Court {
    /**
     * court identifier
     * @type {number}
     * @memberof Court
     */
    'id': number;
    /**
     * court name
     * @type {string}
     * @memberof Court
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CourtAgenda
 */
export interface CourtAgenda {
    /**
     * court agenda identifier
     * @type {number}
     * @memberof CourtAgenda
     */
    'id': number;
    /**
     * court agenda code
     * @type {string}
     * @memberof CourtAgenda
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface DocumentFile
 */
export interface DocumentFile {
    /**
     * 
     * @type {File}
     * @memberof DocumentFile
     */
    'file'?: File;
}
/**
 * 
 * @export
 * @interface DocumentType
 */
export interface DocumentType {
    /**
     * 
     * @type {DocumentTypeEnum}
     * @memberof DocumentType
     */
    'documentType'?: DocumentTypeEnum;
}


/**
 * Typ s√∫dneho rozhodnutia
 * @export
 * @enum {string}
 */

export const DocumentTypeEnum = {
    Uznesenie: 'UZNESENIE',
    Rozsudok: 'ROZSUDOK',
    PlatobnyRozkaz: 'PLATOBNY_ROZKAZ',
    Rozhodnutie: 'ROZHODNUTIE',
    TrestnyRozkaz: 'TRESTNY_ROZKAZ',
    OpravneUznesenie: 'OPRAVNE_UZNESENIE',
    RozsudokPreZmeskanie: 'ROZSUDOK_PRE_ZMESKANIE',
    ZmenkovyPlatobnyRozkaz: 'ZMENKOVY_PLATOBNY_ROZKAZ',
    RozsudokBezOdovodnenia: 'ROZSUDOK_BEZ_ODOVODNENIA',
    RozsudokPreUznanie: 'ROZSUDOK_PRE_UZNANIE',
    DoplnaciRozsudok: 'DOPLNACI_ROZSUDOK',
    RozkazNaPlnenie: 'ROZKAZ_NA_PLNENIE',
    UznesenieBezOdovodnenia: 'UZNESENIE_BEZ_ODOVODNENIA',
    DoplnacieUznesenie: 'DOPLNACIE_UZNESENIE',
    CiastocnyRozsudok: 'CIASTOCNY_ROZSUDOK',
    EuropskyPlatobnyRozkaz: 'EUROPSKY_PLATOBNY_ROZKAZ',
    MedzitymnyRozsudok: 'MEDZITYMNY_ROZSUDOK',
    Osvedcenie: 'OSVEDCENIE',
    Opatrenie: 'OPATRENIE',
    SekovyPlatobnyRozkaz: 'SEKOVY_PLATOBNY_ROZKAZ',
    Ine: 'INE'
} as const;

export type DocumentTypeEnum = typeof DocumentTypeEnum[keyof typeof DocumentTypeEnum];


/**
 * 
 * @export
 * @interface Documents
 */
export interface Documents {
    /**
     * Page size
     * @type {number}
     * @memberof Documents
     */
    'size': number;
    /**
     * total count of elements
     * @type {number}
     * @memberof Documents
     */
    'totalElements': number;
    /**
     * total count of pages
     * @type {number}
     * @memberof Documents
     */
    'totalPages': number;
    /**
     * current page number
     * @type {number}
     * @memberof Documents
     */
    'number': number;
    /**
     * 
     * @type {Array<BasicDocument>}
     * @memberof Documents
     */
    'items'?: Array<BasicDocument>;
}
/**
 * 
 * @export
 * @interface Entities
 */
export interface Entities {
    /**
     * 
     * @type {Array<Entity>}
     * @memberof Entities
     */
    'entities'?: Array<Entity>;
}
/**
 * 
 * @export
 * @interface Entity
 */
export interface Entity {
    /**
     * References entity type by its code
     * @type {string}
     * @memberof Entity
     */
    'code': string;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    'beginOffset': number;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    'endOffset': number;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    'text': string;
    /**
     * 
     * @type {EntitySource}
     * @memberof Entity
     */
    'entitySource'?: EntitySource;
}


/**
 * 
 * @export
 * @interface EntityGroup
 */
export interface EntityGroup {
    /**
     * 
     * @type {string}
     * @memberof EntityGroup
     */
    'id': string;
    /**
     * 
     * @type {Array<Entity>}
     * @memberof EntityGroup
     */
    'entities': Array<Entity>;
}
/**
 * 
 * @export
 * @interface EntityGroups
 */
export interface EntityGroups {
    /**
     * 
     * @type {Array<EntityGroup>}
     * @memberof EntityGroups
     */
    'entityGroups': Array<EntityGroup>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const EntitySource = {
    Human: 'HUMAN',
    Ai: 'AI'
} as const;

export type EntitySource = typeof EntitySource[keyof typeof EntitySource];


/**
 * 
 * @export
 * @interface EntityTypeCategory
 */
export interface EntityTypeCategory {
    /**
     * References entity type category by its code
     * @type {string}
     * @memberof EntityTypeCategory
     */
    'categoryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityTypeCategory
     */
    'label'?: string;
    /**
     * If True this category is merged to previous column occupied by previous category in frontend so that two or more categories can share one column
     * @type {boolean}
     * @memberof EntityTypeCategory
     */
    'mergeWithPrevious'?: boolean;
    /**
     * 
     * @type {Array<EntityTypeDetail>}
     * @memberof EntityTypeCategory
     */
    'entityTypes': Array<EntityTypeDetail>;
}
/**
 * 
 * @export
 * @interface EntityTypeCategoryCode
 */
export interface EntityTypeCategoryCode {
    /**
     * References entity type category by its code
     * @type {string}
     * @memberof EntityTypeCategoryCode
     */
    'categoryCode'?: string;
}
/**
 * 
 * @export
 * @interface EntityTypeCode
 */
export interface EntityTypeCode {
    /**
     * References entity type by its code
     * @type {string}
     * @memberof EntityTypeCode
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface EntityTypeDetail
 */
export interface EntityTypeDetail {
    /**
     * References entity type by its code
     * @type {string}
     * @memberof EntityTypeDetail
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof EntityTypeDetail
     */
    'label': string;
    /**
     * Hexadecimal format for background color of this entity type.
     * @type {string}
     * @memberof EntityTypeDetail
     */
    'color': string;
    /**
     * 
     * @type {EntityTypeGroup}
     * @memberof EntityTypeDetail
     */
    'group': EntityTypeGroup;
    /**
     * 
     * @type {string}
     * @memberof EntityTypeDetail
     */
    'hotkey'?: string;
    /**
     * True if the entityType is supposed to be visible by default
     * @type {boolean}
     * @memberof EntityTypeDetail
     */
    'visibleByDefault'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EntityTypeDetail
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityTypeDetail
     */
    'note'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypeGroup = {
    Anonymous: 'ANONYMOUS',
    Normal: 'NORMAL'
} as const;

export type EntityTypeGroup = typeof EntityTypeGroup[keyof typeof EntityTypeGroup];


/**
 * File format
 * @export
 * @enum {string}
 */

export const FileFormat = {
    Pdf: 'PDF',
    Docx: 'DOCX',
    Rtf: 'RTF'
} as const;

export type FileFormat = typeof FileFormat[keyof typeof FileFormat];


/**
 * 
 * @export
 * @interface FullDocument
 */
export interface FullDocument {
    /**
     * 
     * @type {string}
     * @memberof FullDocument
     */
    'caseFileNumber': string;
    /**
     * 
     * @type {DocumentTypeEnum}
     * @memberof FullDocument
     */
    'documentType'?: DocumentTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof FullDocument
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FullDocument
     */
    'originalAuthor': string;
    /**
     * 
     * @type {string}
     * @memberof FullDocument
     */
    'lastChangeAuthor'?: string;
    /**
     * Timestamp of the created date
     * @type {string}
     * @memberof FullDocument
     */
    'createdDate': string;
    /**
     * Timestamp of the most recent annotations change
     * @type {string}
     * @memberof FullDocument
     */
    'lastChangeDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof FullDocument
     */
    'courtId': number;
    /**
     * 
     * @type {Array<Section>}
     * @memberof FullDocument
     */
    'sections'?: Array<Section>;
    /**
     * Possibly very long text.
     * @type {string}
     * @memberof FullDocument
     */
    'originalText'?: string;
    /**
     * 
     * @type {Array<EntityGroup>}
     * @memberof FullDocument
     */
    'entityGroups': Array<EntityGroup>;
    /**
     * time spent annotating by the user
     * @type {number}
     * @memberof FullDocument
     */
    'userAnnotationTimeInSeconds': number;
    /**
     * 
     * @type {Array<Token>}
     * @memberof FullDocument
     */
    'tokens'?: Array<Token>;
    /**
     * 
     * @type {string}
     * @memberof FullDocument
     */
    'anonymousText'?: string;
}


/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {number}
     * @memberof ModelError
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ModelInfo
 */
export interface ModelInfo {
    /**
     * model version
     * @type {string}
     * @memberof ModelInfo
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface NewDocumentFromSections
 */
export interface NewDocumentFromSections {
    /**
     * 
     * @type {string}
     * @memberof NewDocumentFromSections
     */
    'caseFileNumber': string;
    /**
     * 
     * @type {DocumentTypeEnum}
     * @memberof NewDocumentFromSections
     */
    'documentType'?: DocumentTypeEnum;
    /**
     * 
     * @type {Array<Section>}
     * @memberof NewDocumentFromSections
     */
    'sections'?: Array<Section>;
    /**
     * Possibly very long text.
     * @type {string}
     * @memberof NewDocumentFromSections
     */
    'originalText'?: string;
}


/**
 * 
 * @export
 * @interface NewDocumentFromWholeText
 */
export interface NewDocumentFromWholeText {
    /**
     * 
     * @type {string}
     * @memberof NewDocumentFromWholeText
     */
    'caseFileNumber': string;
    /**
     * 
     * @type {DocumentTypeEnum}
     * @memberof NewDocumentFromWholeText
     */
    'documentType'?: DocumentTypeEnum;
    /**
     * Possibly very long text.
     * @type {string}
     * @memberof NewDocumentFromWholeText
     */
    'originalText'?: string;
}


/**
 * 
 * @export
 * @interface OriginalText
 */
export interface OriginalText {
    /**
     * Possibly very long text.
     * @type {string}
     * @memberof OriginalText
     */
    'originalText'?: string;
}
/**
 * 
 * @export
 * @interface Page
 */
export interface Page {
    /**
     * Page size
     * @type {number}
     * @memberof Page
     */
    'size': number;
    /**
     * total count of elements
     * @type {number}
     * @memberof Page
     */
    'totalElements': number;
    /**
     * total count of pages
     * @type {number}
     * @memberof Page
     */
    'totalPages': number;
    /**
     * current page number
     * @type {number}
     * @memberof Page
     */
    'number': number;
}
/**
 * 
 * @export
 * @interface Region
 */
export interface Region {
    /**
     * region identifier
     * @type {number}
     * @memberof Region
     */
    'id': number;
    /**
     * abbreviated region name
     * @type {string}
     * @memberof Region
     */
    'abbreviatedName': string;
    /**
     * 
     * @type {Array<Court>}
     * @memberof Region
     */
    'courts': Array<Court>;
}
/**
 * 
 * @export
 * @interface Section
 */
export interface Section {
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    'title'?: string;
    /**
     * First section has `beginOffset = 0`
     * @type {number}
     * @memberof Section
     */
    'beginOffset'?: number;
    /**
     * 
     * @type {number}
     * @memberof Section
     */
    'endOffset'?: number;
}
/**
 * 
 * @export
 * @interface Sections
 */
export interface Sections {
    /**
     * 
     * @type {Array<Section>}
     * @memberof Sections
     */
    'sections'?: Array<Section>;
}
/**
 * 
 * @export
 * @interface Statistics
 */
export interface Statistics {
    /**
     * total count of anonymized documents
     * @type {number}
     * @memberof Statistics
     */
    'totalDocuments': number;
    /**
     * total count of anonymized documents without correction
     * @type {number}
     * @memberof Statistics
     */
    'totalDocumentsWithoutCorrection': number;
    /**
     * total count of anonymized documents with correction
     * @type {number}
     * @memberof Statistics
     */
    'totalDocumentsWithCorrection': number;
    /**
     * average number of anonymized document per day
     * @type {number}
     * @memberof Statistics
     */
    'averageDocumentsPerDay': number;
    /**
     * average annotation speed by AI
     * @type {number}
     * @memberof Statistics
     */
    'averageAnnotationSpeed': number;
    /**
     * average annotation speed by user
     * @type {number}
     * @memberof Statistics
     */
    'averageUserAnnotationSpeed': number;
    /**
     * a measure of accuracy
     * @type {number}
     * @memberof Statistics
     */
    'f1Score': number;
    /**
     * the fraction of relevant instances among the retrieved instances
     * @type {number}
     * @memberof Statistics
     */
    'precision': number;
    /**
     * the fraction of the total amount of relevant instances that were actually retrieved
     * @type {number}
     * @memberof Statistics
     */
    'recall': number;
}
/**
 * 
 * @export
 * @interface StatisticsFilterMetadata
 */
export interface StatisticsFilterMetadata {
    /**
     * 
     * @type {Array<Region>}
     * @memberof StatisticsFilterMetadata
     */
    'regions': Array<Region>;
    /**
     * the begin date of statistics
     * @type {string}
     * @memberof StatisticsFilterMetadata
     */
    'beginDate': string;
    /**
     * 
     * @type {Array<CourtAgenda>}
     * @memberof StatisticsFilterMetadata
     */
    'courtAgendas': Array<CourtAgenda>;
}
/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'before'?: string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'after'?: string;
    /**
     * 
     * @type {number}
     * @memberof Token
     */
    'beginOffset'?: number;
    /**
     * 
     * @type {number}
     * @memberof Token
     */
    'endOffset'?: number;
}
/**
 * 
 * @export
 * @interface UpdateDocument
 */
export interface UpdateDocument {
    /**
     * 
     * @type {string}
     * @memberof UpdateDocument
     */
    'caseFileNumber': string;
    /**
     * 
     * @type {DocumentTypeEnum}
     * @memberof UpdateDocument
     */
    'documentType'?: DocumentTypeEnum;
    /**
     * 
     * @type {Array<Entity>}
     * @memberof UpdateDocument
     */
    'entities'?: Array<Entity>;
    /**
     * time spent annotating by the user
     * @type {number}
     * @memberof UpdateDocument
     */
    'userAnnotationTimeInSeconds': number;
}


/**
 * 
 * @export
 * @interface UserAnnotationTimeData
 */
export interface UserAnnotationTimeData {
    /**
     * time spent annotating by the user
     * @type {number}
     * @memberof UserAnnotationTimeData
     */
    'userAnnotationTimeInSeconds': number;
}

/**
 * ActuatorApi - axios parameter creator
 * @export
 */
export const ActuatorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Actuator web endpoint \'info\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/actuator/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActuatorApi - functional programming interface
 * @export
 */
export const ActuatorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActuatorApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Actuator web endpoint \'info\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ActuatorApi - factory interface
 * @export
 */
export const ActuatorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActuatorApiFp(configuration)
    return {
        /**
         * 
         * @summary Actuator web endpoint \'info\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationInfo(options?: any): AxiosPromise<ApplicationInfo> {
            return localVarFp.getApplicationInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActuatorApi - object-oriented interface
 * @export
 * @class ActuatorApi
 * @extends {BaseAPI}
 */
export class ActuatorApi extends BaseAPI {
    /**
     * 
     * @summary Actuator web endpoint \'info\'
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActuatorApi
     */
    public getApplicationInfo(options?: AxiosRequestConfig) {
        return ActuatorApiFp(this.configuration).getApplicationInfo(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DocumentAuditLogApi - axios parameter creator
 * @export
 */
export const DocumentAuditLogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Audit log for document with given ID.
         * @param {string} documentId ID of the document
         * @param {number} [page] Results page you want to retrieve (0..N).
         * @param {number} [size] Number of records per page.
         * @param {Array<Array<string>>} [sort] Sorting criteria \&#39;property,asc|desc\&#39; Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditLogForDocumentById: async (documentId: string, page?: number, size?: number, sort?: Array<Array<string>>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('getAuditLogForDocumentById', 'documentId', documentId)
            const localVarPath = `/document/{documentId}/audit`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentAuditLogApi - functional programming interface
 * @export
 */
export const DocumentAuditLogApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentAuditLogApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Audit log for document with given ID.
         * @param {string} documentId ID of the document
         * @param {number} [page] Results page you want to retrieve (0..N).
         * @param {number} [size] Number of records per page.
         * @param {Array<Array<string>>} [sort] Sorting criteria \&#39;property,asc|desc\&#39; Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuditLogForDocumentById(documentId: string, page?: number, size?: number, sort?: Array<Array<string>>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuditLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuditLogForDocumentById(documentId, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentAuditLogApi - factory interface
 * @export
 */
export const DocumentAuditLogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentAuditLogApiFp(configuration)
    return {
        /**
         * 
         * @summary Audit log for document with given ID.
         * @param {string} documentId ID of the document
         * @param {number} [page] Results page you want to retrieve (0..N).
         * @param {number} [size] Number of records per page.
         * @param {Array<Array<string>>} [sort] Sorting criteria \&#39;property,asc|desc\&#39; Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditLogForDocumentById(documentId: string, page?: number, size?: number, sort?: Array<Array<string>>, options?: any): AxiosPromise<AuditLog> {
            return localVarFp.getAuditLogForDocumentById(documentId, page, size, sort, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentAuditLogApi - object-oriented interface
 * @export
 * @class DocumentAuditLogApi
 * @extends {BaseAPI}
 */
export class DocumentAuditLogApi extends BaseAPI {
    /**
     * 
     * @summary Audit log for document with given ID.
     * @param {string} documentId ID of the document
     * @param {number} [page] Results page you want to retrieve (0..N).
     * @param {number} [size] Number of records per page.
     * @param {Array<Array<string>>} [sort] Sorting criteria \&#39;property,asc|desc\&#39; Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentAuditLogApi
     */
    public getAuditLogForDocumentById(documentId: string, page?: number, size?: number, sort?: Array<Array<string>>, options?: AxiosRequestConfig) {
        return DocumentAuditLogApiFp(this.configuration).getAuditLogForDocumentById(documentId, page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DocumentsApi - axios parameter creator
 * @export
 */
export const DocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new document from sections
         * @param {NewDocumentFromSections} newDocumentFromSections Document to add to the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDocumentFromSections: async (newDocumentFromSections: NewDocumentFromSections, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newDocumentFromSections' is not null or undefined
            assertParamExists('createDocumentFromSections', 'newDocumentFromSections', newDocumentFromSections)
            const localVarPath = `/documents/sections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newDocumentFromSections, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new document by uploading .txt, .docx or .rtf
         * @param {DocumentTypeEnum} documentType 
         * @param {string} caseFileNumber 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDocumentFromUploadedFile: async (documentType: DocumentTypeEnum, caseFileNumber: string, file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentType' is not null or undefined
            assertParamExists('createDocumentFromUploadedFile', 'documentType', documentType)
            // verify required parameter 'caseFileNumber' is not null or undefined
            assertParamExists('createDocumentFromUploadedFile', 'caseFileNumber', caseFileNumber)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('createDocumentFromUploadedFile', 'file', file)
            const localVarPath = `/documents/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (documentType !== undefined) { 
                localVarFormParams.append('documentType', documentType as any);
            }
    
            if (caseFileNumber !== undefined) { 
                localVarFormParams.append('caseFileNumber', caseFileNumber as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new document from a single piece of plain text
         * @param {NewDocumentFromWholeText} newDocumentFromWholeText Document to add to the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDocumentFromWholeText: async (newDocumentFromWholeText: NewDocumentFromWholeText, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newDocumentFromWholeText' is not null or undefined
            assertParamExists('createDocumentFromWholeText', 'newDocumentFromWholeText', newDocumentFromWholeText)
            const localVarPath = `/documents/wholeText`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newDocumentFromWholeText, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete document by Id
         * @param {string} documentId ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentById: async (documentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('deleteDocumentById', 'documentId', documentId)
            const localVarPath = `/document/{documentId}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Detail of the anonymized document identified by ID
         * @param {string} documentId ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showAnonymizedDocumentById: async (documentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('showAnonymizedDocumentById', 'documentId', documentId)
            const localVarPath = `/document/{documentId}/anonymized`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Document detail for a specific ID
         * @param {string} documentId ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showDocumentById: async (documentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('showDocumentById', 'documentId', documentId)
            const localVarPath = `/document/{documentId}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update annotations on existing document by Id
         * @param {string} documentId ID of the document
         * @param {UpdateDocument} updateDocument Document data to be updated. Set of entities will be **completely replaced** by supplied &#x60;.entities&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocumentById: async (documentId: string, updateDocument: UpdateDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('updateDocumentById', 'documentId', documentId)
            // verify required parameter 'updateDocument' is not null or undefined
            assertParamExists('updateDocumentById', 'updateDocument', updateDocument)
            const localVarPath = `/document/{documentId}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentsApi - functional programming interface
 * @export
 */
export const DocumentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create new document from sections
         * @param {NewDocumentFromSections} newDocumentFromSections Document to add to the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDocumentFromSections(newDocumentFromSections: NewDocumentFromSections, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FullDocument>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDocumentFromSections(newDocumentFromSections, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create new document by uploading .txt, .docx or .rtf
         * @param {DocumentTypeEnum} documentType 
         * @param {string} caseFileNumber 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDocumentFromUploadedFile(documentType: DocumentTypeEnum, caseFileNumber: string, file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FullDocument>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDocumentFromUploadedFile(documentType, caseFileNumber, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create new document from a single piece of plain text
         * @param {NewDocumentFromWholeText} newDocumentFromWholeText Document to add to the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDocumentFromWholeText(newDocumentFromWholeText: NewDocumentFromWholeText, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FullDocument>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDocumentFromWholeText(newDocumentFromWholeText, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete document by Id
         * @param {string} documentId ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDocumentById(documentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDocumentById(documentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Detail of the anonymized document identified by ID
         * @param {string} documentId ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showAnonymizedDocumentById(documentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnonymizedDocument>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showAnonymizedDocumentById(documentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Document detail for a specific ID
         * @param {string} documentId ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showDocumentById(documentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FullDocument>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showDocumentById(documentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update annotations on existing document by Id
         * @param {string} documentId ID of the document
         * @param {UpdateDocument} updateDocument Document data to be updated. Set of entities will be **completely replaced** by supplied &#x60;.entities&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDocumentById(documentId: string, updateDocument: UpdateDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FullDocument>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDocumentById(documentId, updateDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentsApi - factory interface
 * @export
 */
export const DocumentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create new document from sections
         * @param {NewDocumentFromSections} newDocumentFromSections Document to add to the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDocumentFromSections(newDocumentFromSections: NewDocumentFromSections, options?: any): AxiosPromise<FullDocument> {
            return localVarFp.createDocumentFromSections(newDocumentFromSections, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create new document by uploading .txt, .docx or .rtf
         * @param {DocumentTypeEnum} documentType 
         * @param {string} caseFileNumber 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDocumentFromUploadedFile(documentType: DocumentTypeEnum, caseFileNumber: string, file: File, options?: any): AxiosPromise<FullDocument> {
            return localVarFp.createDocumentFromUploadedFile(documentType, caseFileNumber, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create new document from a single piece of plain text
         * @param {NewDocumentFromWholeText} newDocumentFromWholeText Document to add to the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDocumentFromWholeText(newDocumentFromWholeText: NewDocumentFromWholeText, options?: any): AxiosPromise<FullDocument> {
            return localVarFp.createDocumentFromWholeText(newDocumentFromWholeText, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete document by Id
         * @param {string} documentId ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentById(documentId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDocumentById(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Detail of the anonymized document identified by ID
         * @param {string} documentId ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showAnonymizedDocumentById(documentId: string, options?: any): AxiosPromise<AnonymizedDocument> {
            return localVarFp.showAnonymizedDocumentById(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Document detail for a specific ID
         * @param {string} documentId ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showDocumentById(documentId: string, options?: any): AxiosPromise<FullDocument> {
            return localVarFp.showDocumentById(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update annotations on existing document by Id
         * @param {string} documentId ID of the document
         * @param {UpdateDocument} updateDocument Document data to be updated. Set of entities will be **completely replaced** by supplied &#x60;.entities&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocumentById(documentId: string, updateDocument: UpdateDocument, options?: any): AxiosPromise<FullDocument> {
            return localVarFp.updateDocumentById(documentId, updateDocument, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentsApi - object-oriented interface
 * @export
 * @class DocumentsApi
 * @extends {BaseAPI}
 */
export class DocumentsApi extends BaseAPI {
    /**
     * 
     * @summary Create new document from sections
     * @param {NewDocumentFromSections} newDocumentFromSections Document to add to the store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public createDocumentFromSections(newDocumentFromSections: NewDocumentFromSections, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).createDocumentFromSections(newDocumentFromSections, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create new document by uploading .txt, .docx or .rtf
     * @param {DocumentTypeEnum} documentType 
     * @param {string} caseFileNumber 
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public createDocumentFromUploadedFile(documentType: DocumentTypeEnum, caseFileNumber: string, file: File, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).createDocumentFromUploadedFile(documentType, caseFileNumber, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create new document from a single piece of plain text
     * @param {NewDocumentFromWholeText} newDocumentFromWholeText Document to add to the store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public createDocumentFromWholeText(newDocumentFromWholeText: NewDocumentFromWholeText, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).createDocumentFromWholeText(newDocumentFromWholeText, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete document by Id
     * @param {string} documentId ID of the document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public deleteDocumentById(documentId: string, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).deleteDocumentById(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Detail of the anonymized document identified by ID
     * @param {string} documentId ID of the document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public showAnonymizedDocumentById(documentId: string, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).showAnonymizedDocumentById(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Document detail for a specific ID
     * @param {string} documentId ID of the document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public showDocumentById(documentId: string, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).showDocumentById(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update annotations on existing document by Id
     * @param {string} documentId ID of the document
     * @param {UpdateDocument} updateDocument Document data to be updated. Set of entities will be **completely replaced** by supplied &#x60;.entities&#x60;. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public updateDocumentById(documentId: string, updateDocument: UpdateDocument, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).updateDocumentById(documentId, updateDocument, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DocumentsExportApi - axios parameter creator
 * @export
 */
export const DocumentsExportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Anonymized document identified by ID in desired format.
         * @param {string} documentId ID of the document
         * @param {FileFormat} fileFormat 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAnonymizedDocumentById: async (documentId: string, fileFormat: FileFormat, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('downloadAnonymizedDocumentById', 'documentId', documentId)
            // verify required parameter 'fileFormat' is not null or undefined
            assertParamExists('downloadAnonymizedDocumentById', 'fileFormat', fileFormat)
            const localVarPath = `/document/{documentId}/export/{fileFormat}/anonymized`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"fileFormat"}}`, encodeURIComponent(String(fileFormat)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Document identified by ID in desired format.
         * @param {string} documentId ID of the document
         * @param {FileFormat} fileFormat 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocumentById: async (documentId: string, fileFormat: FileFormat, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('downloadDocumentById', 'documentId', documentId)
            // verify required parameter 'fileFormat' is not null or undefined
            assertParamExists('downloadDocumentById', 'fileFormat', fileFormat)
            const localVarPath = `/document/{documentId}/export/{fileFormat}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"fileFormat"}}`, encodeURIComponent(String(fileFormat)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentsExportApi - functional programming interface
 * @export
 */
export const DocumentsExportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentsExportApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Anonymized document identified by ID in desired format.
         * @param {string} documentId ID of the document
         * @param {FileFormat} fileFormat 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadAnonymizedDocumentById(documentId: string, fileFormat: FileFormat, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadAnonymizedDocumentById(documentId, fileFormat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Document identified by ID in desired format.
         * @param {string} documentId ID of the document
         * @param {FileFormat} fileFormat 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadDocumentById(documentId: string, fileFormat: FileFormat, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadDocumentById(documentId, fileFormat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentsExportApi - factory interface
 * @export
 */
export const DocumentsExportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentsExportApiFp(configuration)
    return {
        /**
         * 
         * @summary Anonymized document identified by ID in desired format.
         * @param {string} documentId ID of the document
         * @param {FileFormat} fileFormat 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAnonymizedDocumentById(documentId: string, fileFormat: FileFormat, options?: any): AxiosPromise<File> {
            return localVarFp.downloadAnonymizedDocumentById(documentId, fileFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Document identified by ID in desired format.
         * @param {string} documentId ID of the document
         * @param {FileFormat} fileFormat 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocumentById(documentId: string, fileFormat: FileFormat, options?: any): AxiosPromise<File> {
            return localVarFp.downloadDocumentById(documentId, fileFormat, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentsExportApi - object-oriented interface
 * @export
 * @class DocumentsExportApi
 * @extends {BaseAPI}
 */
export class DocumentsExportApi extends BaseAPI {
    /**
     * 
     * @summary Anonymized document identified by ID in desired format.
     * @param {string} documentId ID of the document
     * @param {FileFormat} fileFormat 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsExportApi
     */
    public downloadAnonymizedDocumentById(documentId: string, fileFormat: FileFormat, options?: AxiosRequestConfig) {
        return DocumentsExportApiFp(this.configuration).downloadAnonymizedDocumentById(documentId, fileFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Document identified by ID in desired format.
     * @param {string} documentId ID of the document
     * @param {FileFormat} fileFormat 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsExportApi
     */
    public downloadDocumentById(documentId: string, fileFormat: FileFormat, options?: AxiosRequestConfig) {
        return DocumentsExportApiFp(this.configuration).downloadDocumentById(documentId, fileFormat, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DocumentsMetadataApi - axios parameter creator
 * @export
 */
export const DocumentsMetadataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all documents
         * @param {number} [page] Results page you want to retrieve (0..N).
         * @param {number} [size] Number of records per page.
         * @param {Array<Array<string>>} [sort] Sorting criteria \&#39;property,asc|desc\&#39; Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocuments: async (page?: number, size?: number, sort?: Array<Array<string>>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Metadata of document identified by ID
         * @param {string} documentId ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showDocumentMetadataById: async (documentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('showDocumentMetadataById', 'documentId', documentId)
            const localVarPath = `/document/{documentId}/metadata`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentsMetadataApi - functional programming interface
 * @export
 */
export const DocumentsMetadataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentsMetadataApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all documents
         * @param {number} [page] Results page you want to retrieve (0..N).
         * @param {number} [size] Number of records per page.
         * @param {Array<Array<string>>} [sort] Sorting criteria \&#39;property,asc|desc\&#39; Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDocuments(page?: number, size?: number, sort?: Array<Array<string>>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Documents>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDocuments(page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Metadata of document identified by ID
         * @param {string} documentId ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showDocumentMetadataById(documentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasicDocument>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showDocumentMetadataById(documentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentsMetadataApi - factory interface
 * @export
 */
export const DocumentsMetadataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentsMetadataApiFp(configuration)
    return {
        /**
         * 
         * @summary List all documents
         * @param {number} [page] Results page you want to retrieve (0..N).
         * @param {number} [size] Number of records per page.
         * @param {Array<Array<string>>} [sort] Sorting criteria \&#39;property,asc|desc\&#39; Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocuments(page?: number, size?: number, sort?: Array<Array<string>>, options?: any): AxiosPromise<Documents> {
            return localVarFp.listDocuments(page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Metadata of document identified by ID
         * @param {string} documentId ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showDocumentMetadataById(documentId: string, options?: any): AxiosPromise<BasicDocument> {
            return localVarFp.showDocumentMetadataById(documentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentsMetadataApi - object-oriented interface
 * @export
 * @class DocumentsMetadataApi
 * @extends {BaseAPI}
 */
export class DocumentsMetadataApi extends BaseAPI {
    /**
     * 
     * @summary List all documents
     * @param {number} [page] Results page you want to retrieve (0..N).
     * @param {number} [size] Number of records per page.
     * @param {Array<Array<string>>} [sort] Sorting criteria \&#39;property,asc|desc\&#39; Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsMetadataApi
     */
    public listDocuments(page?: number, size?: number, sort?: Array<Array<string>>, options?: AxiosRequestConfig) {
        return DocumentsMetadataApiFp(this.configuration).listDocuments(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Metadata of document identified by ID
     * @param {string} documentId ID of the document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsMetadataApi
     */
    public showDocumentMetadataById(documentId: string, options?: AxiosRequestConfig) {
        return DocumentsMetadataApiFp(this.configuration).showDocumentMetadataById(documentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EntityTypesApi - axios parameter creator
 * @export
 */
export const EntityTypesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all available entity types organized by category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEntityTypesWithCategories: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/entityTypesWithCategories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EntityTypesApi - functional programming interface
 * @export
 */
export const EntityTypesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EntityTypesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all available entity types organized by category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEntityTypesWithCategories(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EntityTypeCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEntityTypesWithCategories(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EntityTypesApi - factory interface
 * @export
 */
export const EntityTypesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EntityTypesApiFp(configuration)
    return {
        /**
         * 
         * @summary List all available entity types organized by category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEntityTypesWithCategories(options?: any): AxiosPromise<Array<EntityTypeCategory>> {
            return localVarFp.listEntityTypesWithCategories(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EntityTypesApi - object-oriented interface
 * @export
 * @class EntityTypesApi
 * @extends {BaseAPI}
 */
export class EntityTypesApi extends BaseAPI {
    /**
     * 
     * @summary List all available entity types organized by category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypesApi
     */
    public listEntityTypesWithCategories(options?: AxiosRequestConfig) {
        return EntityTypesApiFp(this.configuration).listEntityTypesWithCategories(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExportApi - axios parameter creator
 * @export
 */
export const ExportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary export statistics to \'.csv\' file
         * @param {Array<number>} [courts] the court identifiers
         * @param {Array<string>} [dates] dates
         * @param {Array<number>} [courtAgendas] court agenda identifiers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportStatistics: async (courts?: Array<number>, dates?: Array<string>, courtAgendas?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/export/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (courts) {
                localVarQueryParameter['courts'] = courts.join(COLLECTION_FORMATS.csv);
            }

            if (dates) {
                localVarQueryParameter['dates'] = dates.join(COLLECTION_FORMATS.csv);
            }

            if (courtAgendas) {
                localVarQueryParameter['court-agendas'] = courtAgendas.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExportApi - functional programming interface
 * @export
 */
export const ExportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExportApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary export statistics to \'.csv\' file
         * @param {Array<number>} [courts] the court identifiers
         * @param {Array<string>} [dates] dates
         * @param {Array<number>} [courtAgendas] court agenda identifiers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportStatistics(courts?: Array<number>, dates?: Array<string>, courtAgendas?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportStatistics(courts, dates, courtAgendas, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExportApi - factory interface
 * @export
 */
export const ExportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExportApiFp(configuration)
    return {
        /**
         * 
         * @summary export statistics to \'.csv\' file
         * @param {Array<number>} [courts] the court identifiers
         * @param {Array<string>} [dates] dates
         * @param {Array<number>} [courtAgendas] court agenda identifiers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportStatistics(courts?: Array<number>, dates?: Array<string>, courtAgendas?: Array<number>, options?: any): AxiosPromise<File> {
            return localVarFp.exportStatistics(courts, dates, courtAgendas, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExportApi - object-oriented interface
 * @export
 * @class ExportApi
 * @extends {BaseAPI}
 */
export class ExportApi extends BaseAPI {
    /**
     * 
     * @summary export statistics to \'.csv\' file
     * @param {Array<number>} [courts] the court identifiers
     * @param {Array<string>} [dates] dates
     * @param {Array<number>} [courtAgendas] court agenda identifiers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public exportStatistics(courts?: Array<number>, dates?: Array<string>, courtAgendas?: Array<number>, options?: AxiosRequestConfig) {
        return ExportApiFp(this.configuration).exportStatistics(courts, dates, courtAgendas, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StatisticsApi - axios parameter creator
 * @export
 */
export const StatisticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Anonymization statistics
         * @param {Array<number>} [courts] the court identifiers
         * @param {Array<string>} [dates] dates
         * @param {Array<number>} [courtAgendas] court agenda identifiers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statistics: async (courts?: Array<number>, dates?: Array<string>, courtAgendas?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (courts) {
                localVarQueryParameter['courts'] = courts.join(COLLECTION_FORMATS.csv);
            }

            if (dates) {
                localVarQueryParameter['dates'] = dates.join(COLLECTION_FORMATS.csv);
            }

            if (courtAgendas) {
                localVarQueryParameter['court-agendas'] = courtAgendas.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Metadata for the statistics filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsFilterMetadata: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/statistics/filter-metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatisticsApi - functional programming interface
 * @export
 */
export const StatisticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatisticsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Anonymization statistics
         * @param {Array<number>} [courts] the court identifiers
         * @param {Array<string>} [dates] dates
         * @param {Array<number>} [courtAgendas] court agenda identifiers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statistics(courts?: Array<number>, dates?: Array<string>, courtAgendas?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Statistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statistics(courts, dates, courtAgendas, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Metadata for the statistics filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statisticsFilterMetadata(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatisticsFilterMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statisticsFilterMetadata(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StatisticsApi - factory interface
 * @export
 */
export const StatisticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatisticsApiFp(configuration)
    return {
        /**
         * 
         * @summary Anonymization statistics
         * @param {Array<number>} [courts] the court identifiers
         * @param {Array<string>} [dates] dates
         * @param {Array<number>} [courtAgendas] court agenda identifiers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statistics(courts?: Array<number>, dates?: Array<string>, courtAgendas?: Array<number>, options?: any): AxiosPromise<Statistics> {
            return localVarFp.statistics(courts, dates, courtAgendas, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Metadata for the statistics filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsFilterMetadata(options?: any): AxiosPromise<StatisticsFilterMetadata> {
            return localVarFp.statisticsFilterMetadata(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatisticsApi - object-oriented interface
 * @export
 * @class StatisticsApi
 * @extends {BaseAPI}
 */
export class StatisticsApi extends BaseAPI {
    /**
     * 
     * @summary Anonymization statistics
     * @param {Array<number>} [courts] the court identifiers
     * @param {Array<string>} [dates] dates
     * @param {Array<number>} [courtAgendas] court agenda identifiers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticsApi
     */
    public statistics(courts?: Array<number>, dates?: Array<string>, courtAgendas?: Array<number>, options?: AxiosRequestConfig) {
        return StatisticsApiFp(this.configuration).statistics(courts, dates, courtAgendas, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Metadata for the statistics filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticsApi
     */
    public statisticsFilterMetadata(options?: AxiosRequestConfig) {
        return StatisticsApiFp(this.configuration).statisticsFilterMetadata(options).then((request) => request(this.axios, this.basePath));
    }
}



